//
//  ThrottleImages.m
//  BluetoothTank
//
//  Created by Robert Mannuzza on 7/13/15.
//  Copyright (c) 2015 Me . All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "ThrottleImages.h"


@implementation ThrottleImages

#pragma mark Cache

static UIColor* _pathWay = nil;
static UIColor* _insideHandle = nil;
static UIColor* _outSidePathWay = nil;
static UIColor* _outSideHandle = nil;

static NSShadow* _shadow = nil;

#pragma mark Initialization

+ (void)initialize
{
    // Colors Initialization
    _pathWay = [UIColor colorWithRed: 0.349 green: 0.349 blue: 0.349 alpha: 1];
    _insideHandle = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
    _outSidePathWay = [UIColor colorWithRed: 0.815 green: 0.815 blue: 0.815 alpha: 1];
    _outSideHandle = [UIColor colorWithRed: 0.5 green: 0.5 blue: 0.5 alpha: 1];

    // Shadows Initialization
    _shadow = [NSShadow shadowWithColor: [UIColor.blackColor colorWithAlphaComponent: 0.59] offset: CGSizeMake(3.1, 3.1) blurRadius: 13];

}

#pragma mark Colors

+ (UIColor*)pathWay { return _pathWay; }
+ (UIColor*)insideHandle { return _insideHandle; }
+ (UIColor*)outSidePathWay { return _outSidePathWay; }
+ (UIColor*)outSideHandle { return _outSideHandle; }

#pragma mark Shadows

+ (NSShadow*)shadow { return _shadow; }

#pragma mark Drawing Methods

+ (void)drawJoyStickWithWindowWidth: (CGFloat)windowWidth windowHeight: (CGFloat)windowHeight throttleSpeed: (CGFloat)throttleSpeed
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();


    //// Shadow Declarations
    NSShadow* slotShadow = [NSShadow shadowWithColor: UIColor.blackColor offset: CGSizeMake(0.1, -0.1) blurRadius: 5];

    //// Variable Declarations
    CGFloat throttleWidth = windowWidth / 1.12;
    CGFloat insideThrottleWidth = throttleWidth / 1.12;
    CGFloat insideThrottleX = throttleWidth / 2.0 - insideThrottleWidth / 2.0;
    CGFloat insideThrottleY = insideThrottleX / 2.0;
    CGFloat throttleXValue = windowWidth / 2.0 - throttleWidth / 2.0;
    CGFloat middleSlotWidth = windowWidth / 3.83 / 2.0;
    CGFloat middleSlotX = middleSlotWidth / 2.0;
    CGFloat middleBarWidth = windowWidth / 3.83;
    CGFloat middleLineWidth = middleBarWidth / 60.0;
    CGFloat middleBarY = windowWidth / 2.0 - middleBarWidth / 2.0;
    CGFloat throttleHeight = windowHeight / 7.50;
    CGFloat insideThrottleHeight = throttleHeight - insideThrottleX;
    CGFloat middleLineX = windowHeight / 2.0;
    CGFloat middleSlotHeight = windowHeight - 40;
    CGFloat throttleYValue = middleSlotHeight * throttleSpeed + 1;
    CGFloat middleSlotY = 20;

    //// Group 2
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, middleBarY, 0);



        //// Rectangle Drawing
        UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(0, 0, middleBarWidth, windowHeight) cornerRadius: 14];
        [ThrottleImages.outSidePathWay setFill];
        [rectanglePath fill];


        //// Bezier Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 0, middleLineX);
        CGContextScaleCTM(context, middleLineWidth, 1);

        UIBezierPath* bezierPath = UIBezierPath.bezierPath;
        [bezierPath moveToPoint: CGPointMake(0, 0)];
        [bezierPath addLineToPoint: CGPointMake(60, 0)];
        [UIColor.blackColor setStroke];
        bezierPath.lineWidth = middleLineWidth;
        [bezierPath stroke];

        CGContextRestoreGState(context);


        //// Rectangle 2 Drawing
        UIBezierPath* rectangle2Path = [UIBezierPath bezierPathWithRect: CGRectMake(middleSlotX, middleSlotY, middleSlotWidth, middleSlotHeight)];
        CGContextSaveGState(context);
        CGContextSetShadowWithColor(context, slotShadow.shadowOffset, slotShadow.shadowBlurRadius, [slotShadow.shadowColor CGColor]);
        [ThrottleImages.pathWay setFill];
        [rectangle2Path fill];
        CGContextRestoreGState(context);




        CGContextRestoreGState(context);
    }


    //// Group
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, throttleXValue, (throttleYValue - 1));

        CGContextSetShadowWithColor(context, ThrottleImages.shadow.shadowOffset, ThrottleImages.shadow.shadowBlurRadius, [ThrottleImages.shadow.shadowColor CGColor]);
        CGContextBeginTransparencyLayer(context, NULL);


        //// Oval Drawing
        UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0, -0, throttleWidth, throttleHeight)];
        [ThrottleImages.outSideHandle setFill];
        [ovalPath fill];


        //// Oval 2 Drawing
        UIBezierPath* oval2Path = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(insideThrottleX, (insideThrottleY - 0.0049941021604), insideThrottleWidth, insideThrottleHeight)];
        [ThrottleImages.insideHandle setFill];
        [oval2Path fill];


        CGContextEndTransparencyLayer(context);

        CGContextRestoreGState(context);
    }
}

@end



@implementation NSShadow (PaintCodeAdditions)

- (instancetype)initWithColor: (UIColor*)color offset: (CGSize)offset blurRadius: (CGFloat)blurRadius
{
    self = super.init;
    if (self)
    {
        self.shadowColor = color;
        self.shadowOffset = offset;
        self.shadowBlurRadius = blurRadius;
    }
    return self;
}

+ (instancetype)shadowWithColor: (UIColor*)color offset: (CGSize)offset blurRadius: (CGFloat)blurRadius
{
    return [self.alloc initWithColor: color offset: offset blurRadius: blurRadius];
}

- (void)set
{
    CGContextSetShadowWithColor(UIGraphicsGetCurrentContext(), self.shadowOffset, self.shadowBlurRadius, [self.shadowColor CGColor]);
}

@end
