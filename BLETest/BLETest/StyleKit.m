//
//  StyleKit.m
//  BluetoothTank
//
//  Created by Robert Mannuzza on 7/13/15.
//  Copyright (c) 2015 Me . All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "StyleKit.h"


@implementation StyleKit

#pragma mark Cache

static UIColor* _pathWay = nil;
static UIColor* _insideHandle = nil;
static UIColor* _outSidePathWay = nil;
static UIColor* _outSideHandle = nil;

static NSShadow* _shadow = nil;

#pragma mark Initialization

+ (void)initialize
{
    // Colors Initialization
    _pathWay = [UIColor colorWithRed: 0.349 green: 0.349 blue: 0.349 alpha: 1];
    _insideHandle = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
    _outSidePathWay = [UIColor colorWithRed: 0.815 green: 0.815 blue: 0.815 alpha: 1];
    _outSideHandle = [UIColor colorWithRed: 0.5 green: 0.5 blue: 0.5 alpha: 1];

    // Shadows Initialization
    _shadow = [NSShadow shadowWithColor: [UIColor.blackColor colorWithAlphaComponent: 0.59] offset: CGSizeMake(3.1, 3.1) blurRadius: 13];

}

#pragma mark Colors

+ (UIColor*)pathWay { return _pathWay; }
+ (UIColor*)insideHandle { return _insideHandle; }
+ (UIColor*)outSidePathWay { return _outSidePathWay; }
+ (UIColor*)outSideHandle { return _outSideHandle; }

#pragma mark Shadows

+ (NSShadow*)shadow { return _shadow; }

#pragma mark Drawing Methods

+ (void)drawJoyStickWithWindowWidth: (CGFloat)windowWidth windowHeight: (CGFloat)windowHeight throttleSpeed: (CGFloat)throttleSpeed
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();


    //// Shadow Declarations
    NSShadow* slotShadow = [NSShadow shadowWithColor: UIColor.blackColor offset: CGSizeMake(0.1, -0.1) blurRadius: 5];

    //// Variable Declarations
    CGFloat throttleWidth = windowWidth / 1.12;
    CGFloat insideThrottleWidth = throttleWidth / 1.12;
    CGFloat insideThrottleX = throttleWidth / 2.0 - insideThrottleWidth / 2.0;
    CGFloat throttleXValue = windowWidth / 2.0 - throttleWidth / 2.0;
    CGFloat middleSlotWidth = windowWidth / 3.83 / 2.0;
    CGFloat middleSlotX = middleSlotWidth / 2.0;
    CGFloat middleBarWidth = windowWidth / 3.83;
    CGFloat middleLineWidth = middleBarWidth / 60.0;
    CGFloat middleBarY = windowWidth / 2.0 - middleBarWidth / 2.0;
    CGFloat throttleHeight = windowHeight / 7.50;
    CGFloat insideThrottleHeight = throttleHeight - insideThrottleX;
    BOOL notNeg = insideThrottleHeight > 0;
    CGFloat actualHeightInsideThrottle = notNeg ? insideThrottleHeight : 1;
    CGFloat insideThrottleY = throttleHeight / 2.0 - actualHeightInsideThrottle / 2.0;
    CGFloat middleSlotY = throttleHeight / 2.0;
    CGFloat middleLineX = windowHeight / 2.0;
    CGFloat middleSlotHeight = windowHeight - middleSlotY * 2;
    CGFloat throttleYValue = middleSlotHeight * throttleSpeed + 1;

    //// Group 2
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, (middleBarY + 0.478260866575), 0);



        //// Rectangle Drawing
        UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: CGRectMake(0, 0, middleBarWidth, windowHeight) cornerRadius: 14];
        [StyleKit.outSidePathWay setFill];
        [rectanglePath fill];


        //// Bezier Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 0, middleLineX);
        CGContextScaleCTM(context, middleLineWidth, 1);

        UIBezierPath* bezierPath = UIBezierPath.bezierPath;
        [bezierPath moveToPoint: CGPointMake(0, 0)];
        [bezierPath addLineToPoint: CGPointMake(60, 0)];
        [UIColor.blackColor setStroke];
        bezierPath.lineWidth = middleLineWidth;
        [bezierPath stroke];

        CGContextRestoreGState(context);


        //// Rectangle 2 Drawing
        UIBezierPath* rectangle2Path = [UIBezierPath bezierPathWithRect: CGRectMake(middleSlotX, middleSlotY, middleSlotWidth, middleSlotHeight)];
        CGContextSaveGState(context);
        CGContextSetShadowWithColor(context, slotShadow.shadowOffset, slotShadow.shadowBlurRadius, [slotShadow.shadowColor CGColor]);
        [StyleKit.pathWay setFill];
        [rectangle2Path fill];
        CGContextRestoreGState(context);




        CGContextRestoreGState(context);
    }


    //// Group
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, (throttleXValue + 0.478260866575), (throttleYValue - 1));

        CGContextSetShadowWithColor(context, StyleKit.shadow.shadowOffset, StyleKit.shadow.shadowBlurRadius, [StyleKit.shadow.shadowColor CGColor]);
        CGContextBeginTransparencyLayer(context, NULL);


        //// Oval Drawing
        UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0, 0, throttleWidth, throttleHeight)];
        [StyleKit.outSideHandle setFill];
        [ovalPath fill];


        //// Oval 2 Drawing
        UIBezierPath* oval2Path = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(insideThrottleX, (insideThrottleY - 0.00593944075967), insideThrottleWidth, actualHeightInsideThrottle)];
        [StyleKit.insideHandle setFill];
        [oval2Path fill];


        CGContextEndTransparencyLayer(context);

        CGContextRestoreGState(context);
    }
}

+ (void)drawCompassWithAngle: (CGFloat)angle
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* botLeft = [UIColor colorWithRed: 0.427 green: 0.427 blue: 0.427 alpha: 1];
    UIColor* topRight = [UIColor colorWithRed: 0.429 green: 0.429 blue: 0.429 alpha: 1];
    UIColor* botRight = [UIColor colorWithRed: 0.738 green: 0.738 blue: 0.738 alpha: 1];
    UIColor* topLeft = [UIColor colorWithRed: 0.737 green: 0.737 blue: 0.737 alpha: 1];
    UIColor* compassTextColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];

    //// Shadow Declarations
    NSShadow* textOuterShowow = [NSShadow shadowWithColor: UIColor.whiteColor offset: CGSizeMake(0.1, -0.1) blurRadius: 1];

    //// Variable Declarations
    CGFloat compassLinesLength = 0.8;
    CGFloat textAngle = angle * -1;
    CGFloat compassLinesScale = 0.5;

    //// outSide Drawing
    UIBezierPath* outSidePath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(0, 0, 240, 240)];
    [UIColor.grayColor setFill];
    [outSidePath fill];


    //// Group
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 120, 120);
        CGContextRotateCTM(context, -angle * M_PI / 180);



        //// topLeftPie
        {
            CGContextSaveGState(context);



            //// inSideOval 2 Drawing
            CGRect inSideOval2Rect = CGRectMake(-100, -100, 200, 200);
            UIBezierPath* inSideOval2Path = UIBezierPath.bezierPath;
            [inSideOval2Path addArcWithCenter: CGPointMake(CGRectGetMidX(inSideOval2Rect), CGRectGetMidY(inSideOval2Rect)) radius: CGRectGetWidth(inSideOval2Rect) / 2 startAngle: 270 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
            [inSideOval2Path addLineToPoint: CGPointMake(CGRectGetMidX(inSideOval2Rect), CGRectGetMidY(inSideOval2Rect))];
            [inSideOval2Path closePath];

            [topRight setFill];
            [inSideOval2Path fill];


            //// B90 Drawing
            CGContextSaveGState(context);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b90Path = UIBezierPath.bezierPath;
            [b90Path moveToPoint: CGPointMake(0, 0)];
            [b90Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b90Path.lineWidth = 1.5;
            [b90Path stroke];

            CGContextRestoreGState(context);


            //// B75 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 15 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b75Path = UIBezierPath.bezierPath;
            [b75Path moveToPoint: CGPointMake(0, 0)];
            [b75Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b75Path.lineWidth = 1.5;
            [b75Path stroke];

            CGContextRestoreGState(context);


            //// B60 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 30 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b60Path = UIBezierPath.bezierPath;
            [b60Path moveToPoint: CGPointMake(0, 0)];
            [b60Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b60Path.lineWidth = 1.5;
            [b60Path stroke];

            CGContextRestoreGState(context);


            //// B45 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 45 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b45Path = UIBezierPath.bezierPath;
            [b45Path moveToPoint: CGPointMake(0, 0)];
            [b45Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b45Path.lineWidth = 1.5;
            [b45Path stroke];

            CGContextRestoreGState(context);


            //// B30 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 60 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b30Path = UIBezierPath.bezierPath;
            [b30Path moveToPoint: CGPointMake(0, 0)];
            [b30Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b30Path.lineWidth = 1.5;
            [b30Path stroke];

            CGContextRestoreGState(context);


            //// B15 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 75 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b15Path = UIBezierPath.bezierPath;
            [b15Path moveToPoint: CGPointMake(0, 0)];
            [b15Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b15Path.lineWidth = 1.5;
            [b15Path stroke];

            CGContextRestoreGState(context);


            //// B00 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 90 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b00Path = UIBezierPath.bezierPath;
            [b00Path moveToPoint: CGPointMake(0, 0)];
            [b00Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b00Path.lineWidth = 1.5;
            [b00Path stroke];

            CGContextRestoreGState(context);



            CGContextRestoreGState(context);
        }


        //// topRightPie
        {
            CGContextSaveGState(context);
            CGContextRotateCTM(context, -90 * M_PI / 180);



            //// inSideOval Drawing
            CGRect inSideOvalRect = CGRectMake(-100, -100, 200, 200);
            UIBezierPath* inSideOvalPath = UIBezierPath.bezierPath;
            [inSideOvalPath addArcWithCenter: CGPointMake(CGRectGetMidX(inSideOvalRect), CGRectGetMidY(inSideOvalRect)) radius: CGRectGetWidth(inSideOvalRect) / 2 startAngle: 270 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
            [inSideOvalPath addLineToPoint: CGPointMake(CGRectGetMidX(inSideOvalRect), CGRectGetMidY(inSideOvalRect))];
            [inSideOvalPath closePath];

            [topLeft setFill];
            [inSideOvalPath fill];


            //// B Drawing
            CGContextSaveGState(context);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* bPath = UIBezierPath.bezierPath;
            [bPath moveToPoint: CGPointMake(0, 0)];
            [bPath addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            bPath.lineWidth = 1.5;
            [bPath stroke];

            CGContextRestoreGState(context);


            //// B 2 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 15 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b2Path = UIBezierPath.bezierPath;
            [b2Path moveToPoint: CGPointMake(0, 0)];
            [b2Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b2Path.lineWidth = 1.5;
            [b2Path stroke];

            CGContextRestoreGState(context);


            //// B 3 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 30 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b3Path = UIBezierPath.bezierPath;
            [b3Path moveToPoint: CGPointMake(0, 0)];
            [b3Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b3Path.lineWidth = 1.5;
            [b3Path stroke];

            CGContextRestoreGState(context);


            //// B 4 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 45 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b4Path = UIBezierPath.bezierPath;
            [b4Path moveToPoint: CGPointMake(0, 0)];
            [b4Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b4Path.lineWidth = 1.5;
            [b4Path stroke];

            CGContextRestoreGState(context);


            //// B 5 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 60 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b5Path = UIBezierPath.bezierPath;
            [b5Path moveToPoint: CGPointMake(0, 0)];
            [b5Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b5Path.lineWidth = 1.5;
            [b5Path stroke];

            CGContextRestoreGState(context);


            //// B 6 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 75 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b6Path = UIBezierPath.bezierPath;
            [b6Path moveToPoint: CGPointMake(0, 0)];
            [b6Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b6Path.lineWidth = 1.5;
            [b6Path stroke];

            CGContextRestoreGState(context);


            //// B 7 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 90 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b7Path = UIBezierPath.bezierPath;
            [b7Path moveToPoint: CGPointMake(0, 0)];
            [b7Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b7Path.lineWidth = 1.5;
            [b7Path stroke];

            CGContextRestoreGState(context);



            CGContextRestoreGState(context);
        }


        //// botLeftPie
        {
            CGContextSaveGState(context);
            CGContextRotateCTM(context, -180 * M_PI / 180);



            //// inSideOval 3 Drawing
            CGRect inSideOval3Rect = CGRectMake(-100, -100, 200, 200);
            UIBezierPath* inSideOval3Path = UIBezierPath.bezierPath;
            [inSideOval3Path addArcWithCenter: CGPointMake(CGRectGetMidX(inSideOval3Rect), CGRectGetMidY(inSideOval3Rect)) radius: CGRectGetWidth(inSideOval3Rect) / 2 startAngle: 270 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
            [inSideOval3Path addLineToPoint: CGPointMake(CGRectGetMidX(inSideOval3Rect), CGRectGetMidY(inSideOval3Rect))];
            [inSideOval3Path closePath];

            [botLeft setFill];
            [inSideOval3Path fill];


            //// B 8 Drawing
            CGContextSaveGState(context);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b8Path = UIBezierPath.bezierPath;
            [b8Path moveToPoint: CGPointMake(0, 0)];
            [b8Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b8Path.lineWidth = 1.5;
            [b8Path stroke];

            CGContextRestoreGState(context);


            //// B 9 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 15 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b9Path = UIBezierPath.bezierPath;
            [b9Path moveToPoint: CGPointMake(0, 0)];
            [b9Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b9Path.lineWidth = 1.5;
            [b9Path stroke];

            CGContextRestoreGState(context);


            //// B 10 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 30 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b10Path = UIBezierPath.bezierPath;
            [b10Path moveToPoint: CGPointMake(0, 0)];
            [b10Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b10Path.lineWidth = 1.5;
            [b10Path stroke];

            CGContextRestoreGState(context);


            //// B 11 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 45 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b11Path = UIBezierPath.bezierPath;
            [b11Path moveToPoint: CGPointMake(0, 0)];
            [b11Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b11Path.lineWidth = 1.5;
            [b11Path stroke];

            CGContextRestoreGState(context);


            //// B 12 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 60 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b12Path = UIBezierPath.bezierPath;
            [b12Path moveToPoint: CGPointMake(0, 0)];
            [b12Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b12Path.lineWidth = 1.5;
            [b12Path stroke];

            CGContextRestoreGState(context);


            //// B 13 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 75 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b13Path = UIBezierPath.bezierPath;
            [b13Path moveToPoint: CGPointMake(0, 0)];
            [b13Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b13Path.lineWidth = 1.5;
            [b13Path stroke];

            CGContextRestoreGState(context);


            //// B 14 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 90 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b14Path = UIBezierPath.bezierPath;
            [b14Path moveToPoint: CGPointMake(0, 0)];
            [b14Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b14Path.lineWidth = 1.5;
            [b14Path stroke];

            CGContextRestoreGState(context);



            CGContextRestoreGState(context);
        }


        //// botRightPie
        {
            CGContextSaveGState(context);
            CGContextRotateCTM(context, -270 * M_PI / 180);



            //// inSideOval 4 Drawing
            CGRect inSideOval4Rect = CGRectMake(-100, -100, 200, 200);
            UIBezierPath* inSideOval4Path = UIBezierPath.bezierPath;
            [inSideOval4Path addArcWithCenter: CGPointMake(CGRectGetMidX(inSideOval4Rect), CGRectGetMidY(inSideOval4Rect)) radius: CGRectGetWidth(inSideOval4Rect) / 2 startAngle: 270 * M_PI/180 endAngle: 0 * M_PI/180 clockwise: YES];
            [inSideOval4Path addLineToPoint: CGPointMake(CGRectGetMidX(inSideOval4Rect), CGRectGetMidY(inSideOval4Rect))];
            [inSideOval4Path closePath];

            [botRight setFill];
            [inSideOval4Path fill];


            //// B 16 Drawing
            CGContextSaveGState(context);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b16Path = UIBezierPath.bezierPath;
            [b16Path moveToPoint: CGPointMake(0, 0)];
            [b16Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b16Path.lineWidth = 1.5;
            [b16Path stroke];

            CGContextRestoreGState(context);


            //// B 17 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 15 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b17Path = UIBezierPath.bezierPath;
            [b17Path moveToPoint: CGPointMake(0, 0)];
            [b17Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b17Path.lineWidth = 1.5;
            [b17Path stroke];

            CGContextRestoreGState(context);


            //// B 18 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 30 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b18Path = UIBezierPath.bezierPath;
            [b18Path moveToPoint: CGPointMake(0, 0)];
            [b18Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b18Path.lineWidth = 1.5;
            [b18Path stroke];

            CGContextRestoreGState(context);


            //// B 19 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 45 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b19Path = UIBezierPath.bezierPath;
            [b19Path moveToPoint: CGPointMake(0, 0)];
            [b19Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b19Path.lineWidth = 1.5;
            [b19Path stroke];

            CGContextRestoreGState(context);


            //// B 20 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 60 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b20Path = UIBezierPath.bezierPath;
            [b20Path moveToPoint: CGPointMake(0, 0)];
            [b20Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b20Path.lineWidth = 1.5;
            [b20Path stroke];

            CGContextRestoreGState(context);


            //// B 21 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 75 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b21Path = UIBezierPath.bezierPath;
            [b21Path moveToPoint: CGPointMake(0, 0)];
            [b21Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b21Path.lineWidth = 1.5;
            [b21Path stroke];

            CGContextRestoreGState(context);


            //// B 22 Drawing
            CGContextSaveGState(context);
            CGContextRotateCTM(context, 90 * M_PI / 180);
            CGContextScaleCTM(context, compassLinesScale, compassLinesLength);

            UIBezierPath* b22Path = UIBezierPath.bezierPath;
            [b22Path moveToPoint: CGPointMake(0, 0)];
            [b22Path addLineToPoint: CGPointMake(0, -100)];
            [UIColor.blackColor setStroke];
            b22Path.lineWidth = 1.5;
            [b22Path stroke];

            CGContextRestoreGState(context);



            CGContextRestoreGState(context);
        }


        //// North Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -0, -94);
        CGContextRotateCTM(context, -textAngle * M_PI / 180);

        CGRect northRect = CGRectMake(-5, -6, 10, 12);
        {
            NSString* textContent = @"N";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* northStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            northStyle.alignment = NSTextAlignmentCenter;

            NSDictionary* northFontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 10], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: northStyle};

            CGFloat northTextHeight = [textContent boundingRectWithSize: CGSizeMake(northRect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: northFontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, northRect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(northRect), CGRectGetMinY(northRect) + (CGRectGetHeight(northRect) - northTextHeight) / 2, CGRectGetWidth(northRect), northTextHeight) withAttributes: northFontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// West Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -94.5, -0.5);
        CGContextRotateCTM(context, -textAngle * M_PI / 180);

        CGRect westRect = CGRectMake(-5.5, -5.5, 11, 12);
        {
            NSString* textContent = @"W";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* westStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            westStyle.alignment = NSTextAlignmentCenter;

            NSDictionary* westFontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 10], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: westStyle};

            CGFloat westTextHeight = [textContent boundingRectWithSize: CGSizeMake(westRect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: westFontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, westRect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(westRect), CGRectGetMinY(westRect) + (CGRectGetHeight(westRect) - westTextHeight) / 2, CGRectGetWidth(westRect), westTextHeight) withAttributes: westFontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// South Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -0.5, 94);
        CGContextRotateCTM(context, -textAngle * M_PI / 180);

        CGRect southRect = CGRectMake(-5.5, -6, 11, 12);
        {
            NSString* textContent = @"S";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* southStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            southStyle.alignment = NSTextAlignmentCenter;

            NSDictionary* southFontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 10], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: southStyle};

            CGFloat southTextHeight = [textContent boundingRectWithSize: CGSizeMake(southRect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: southFontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, southRect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(southRect), CGRectGetMinY(southRect) + (CGRectGetHeight(southRect) - southTextHeight) / 2, CGRectGetWidth(southRect), southTextHeight) withAttributes: southFontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// East Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 94.5, -1);
        CGContextRotateCTM(context, -textAngle * M_PI / 180);

        CGRect eastRect = CGRectMake(-5.5, -5.5, 11, 12.5);
        {
            NSString* textContent = @"E";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* eastStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            eastStyle.alignment = NSTextAlignmentCenter;

            NSDictionary* eastFontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 10], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: eastStyle};

            CGFloat eastTextHeight = [textContent boundingRectWithSize: CGSizeMake(eastRect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: eastFontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, eastRect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(eastRect), CGRectGetMinY(eastRect) + (CGRectGetHeight(eastRect) - eastTextHeight) / 2, CGRectGetWidth(eastRect), eastTextHeight) withAttributes: eastFontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text Drawing
        CGRect textRect = CGRectMake(-2, -88, 6, 8);
        {
            NSString* textContent = @"0°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* textStyle = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            textStyle.alignment = NSTextAlignmentCenter;

            NSDictionary* textFontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: textStyle};

            CGFloat textTextHeight = [textContent boundingRectWithSize: CGSizeMake(textRect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: textFontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, textRect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(textRect), CGRectGetMinY(textRect) + (CGRectGetHeight(textRect) - textTextHeight) / 2, CGRectGetWidth(textRect), textTextHeight) withAttributes: textFontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }


        //// Text 1 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 22.71, -80.88);
        CGContextRotateCTM(context, 15 * M_PI / 180);

        CGRect text1Rect = CGRectMake(-4, -4, 8, 8);
        {
            NSString* textContent = @"15°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text1Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text1Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text1FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text1Style};

            CGFloat text1TextHeight = [textContent boundingRectWithSize: CGSizeMake(text1Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text1FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text1Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text1Rect), CGRectGetMinY(text1Rect) + (CGRectGetHeight(text1Rect) - text1TextHeight) / 2, CGRectGetWidth(text1Rect), text1TextHeight) withAttributes: text1FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 2 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 41.4, -77.71);
        CGContextRotateCTM(context, 30 * M_PI / 180);

        CGRect text2Rect = CGRectMake(0, 0, 8, 8);
        {
            NSString* textContent = @"30°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text2Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text2Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text2FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text2Style};

            CGFloat text2TextHeight = [textContent boundingRectWithSize: CGSizeMake(text2Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text2FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text2Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text2Rect), CGRectGetMinY(text2Rect) + (CGRectGetHeight(text2Rect) - text2TextHeight) / 2, CGRectGetWidth(text2Rect), text2TextHeight) withAttributes: text2FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 3 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 60.1, -64.35);
        CGContextRotateCTM(context, 45 * M_PI / 180);

        CGRect text3Rect = CGRectMake(0, 0, 8, 8);
        {
            NSString* textContent = @"45°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text3Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text3Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text3FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text3Style};

            CGFloat text3TextHeight = [textContent boundingRectWithSize: CGSizeMake(text3Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text3FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text3Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text3Rect), CGRectGetMinY(text3Rect) + (CGRectGetHeight(text3Rect) - text3TextHeight) / 2, CGRectGetWidth(text3Rect), text3TextHeight) withAttributes: text3FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 4 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 74.71, -46.6);
        CGContextRotateCTM(context, 60 * M_PI / 180);

        CGRect text4Rect = CGRectMake(0, 0, 8, 8);
        {
            NSString* textContent = @"60°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text4Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text4Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text4FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text4Style};

            CGFloat text4TextHeight = [textContent boundingRectWithSize: CGSizeMake(text4Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text4FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text4Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text4Rect), CGRectGetMinY(text4Rect) + (CGRectGetHeight(text4Rect) - text4TextHeight) / 2, CGRectGetWidth(text4Rect), text4TextHeight) withAttributes: text4FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 5 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 84.22, -25.67);
        CGContextRotateCTM(context, 75 * M_PI / 180);

        CGRect text5Rect = CGRectMake(0, 0, 8, 8);
        {
            NSString* textContent = @"75°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text5Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text5Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text5FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text5Style};

            CGFloat text5TextHeight = [textContent boundingRectWithSize: CGSizeMake(text5Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text5FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text5Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text5Rect), CGRectGetMinY(text5Rect) + (CGRectGetHeight(text5Rect) - text5TextHeight) / 2, CGRectGetWidth(text5Rect), text5TextHeight) withAttributes: text5FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 6 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 87, -3);
        CGContextRotateCTM(context, 90 * M_PI / 180);

        CGRect text6Rect = CGRectMake(0, 0, 8, 7);
        {
            NSString* textContent = @"90°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text6Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text6Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text6FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text6Style};

            CGFloat text6TextHeight = [textContent boundingRectWithSize: CGSizeMake(text6Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text6FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text6Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text6Rect), CGRectGetMinY(text6Rect) + (CGRectGetHeight(text6Rect) - text6TextHeight) / 2, CGRectGetWidth(text6Rect), text6TextHeight) withAttributes: text6FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 7 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 80.96, 22.8);
        CGContextRotateCTM(context, 106 * M_PI / 180);

        CGRect text7Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"105°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text7Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text7Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text7FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text7Style};

            CGFloat text7TextHeight = [textContent boundingRectWithSize: CGSizeMake(text7Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text7FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text7Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text7Rect), CGRectGetMinY(text7Rect) + (CGRectGetHeight(text7Rect) - text7TextHeight) / 2, CGRectGetWidth(text7Rect), text7TextHeight) withAttributes: text7FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 8 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 72.25, 42.87);
        CGContextRotateCTM(context, 120 * M_PI / 180);

        CGRect text8Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"120°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text8Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text8Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text8FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text8Style};

            CGFloat text8TextHeight = [textContent boundingRectWithSize: CGSizeMake(text8Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text8FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text8Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text8Rect), CGRectGetMinY(text8Rect) + (CGRectGetHeight(text8Rect) - text8TextHeight) / 2, CGRectGetWidth(text8Rect), text8TextHeight) withAttributes: text8FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 9 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 58.69, 60.1);
        CGContextRotateCTM(context, 135 * M_PI / 180);

        CGRect text9Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"135°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text9Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text9Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text9FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text9Style};

            CGFloat text9TextHeight = [textContent boundingRectWithSize: CGSizeMake(text9Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text9FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text9Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text9Rect), CGRectGetMinY(text9Rect) + (CGRectGetHeight(text9Rect) - text9TextHeight) / 2, CGRectGetWidth(text9Rect), text9TextHeight) withAttributes: text9FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 10 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 41.13, 73.25);
        CGContextRotateCTM(context, 150 * M_PI / 180);

        CGRect text10Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"150°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text10Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text10Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text10FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text10Style};

            CGFloat text10TextHeight = [textContent boundingRectWithSize: CGSizeMake(text10Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text10FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text10Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text10Rect), CGRectGetMinY(text10Rect) + (CGRectGetHeight(text10Rect) - text10TextHeight) / 2, CGRectGetWidth(text10Rect), text10TextHeight) withAttributes: text10FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 11 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, 20.78, 81.4);
        CGContextRotateCTM(context, 165 * M_PI / 180);

        CGRect text11Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"165°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text11Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text11Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text11FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text11Style};

            CGFloat text11TextHeight = [textContent boundingRectWithSize: CGSizeMake(text11Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text11FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text11Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text11Rect), CGRectGetMinY(text11Rect) + (CGRectGetHeight(text11Rect) - text11TextHeight) / 2, CGRectGetWidth(text11Rect), text11TextHeight) withAttributes: text11FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 12 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -1, 84);
        CGContextRotateCTM(context, 180 * M_PI / 180);

        CGRect text12Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"180°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text12Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text12Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text12FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text12Style};

            CGFloat text12TextHeight = [textContent boundingRectWithSize: CGSizeMake(text12Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text12FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text12Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text12Rect), CGRectGetMinY(text12Rect) + (CGRectGetHeight(text12Rect) - text12TextHeight) / 2, CGRectGetWidth(text12Rect), text12TextHeight) withAttributes: text12FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 13 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -22.71, 80.88);
        CGContextRotateCTM(context, 195 * M_PI / 180);

        CGRect text13Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"195°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text13Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text13Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text13FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text13Style};

            CGFloat text13TextHeight = [textContent boundingRectWithSize: CGSizeMake(text13Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text13FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text13Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text13Rect), CGRectGetMinY(text13Rect) + (CGRectGetHeight(text13Rect) - text13TextHeight) / 2, CGRectGetWidth(text13Rect), text13TextHeight) withAttributes: text13FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 14 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -42, 72.75);
        CGContextRotateCTM(context, 210 * M_PI / 180);

        CGRect text14Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"210°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text14Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text14Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text14FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text14Style};

            CGFloat text14TextHeight = [textContent boundingRectWithSize: CGSizeMake(text14Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text14FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text14Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text14Rect), CGRectGetMinY(text14Rect) + (CGRectGetHeight(text14Rect) - text14TextHeight) / 2, CGRectGetWidth(text14Rect), text14TextHeight) withAttributes: text14FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 15 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -60.1, 58.69);
        CGContextRotateCTM(context, 225 * M_PI / 180);

        CGRect text15Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"225°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text15Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text15Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text15FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text15Style};

            CGFloat text15TextHeight = [textContent boundingRectWithSize: CGSizeMake(text15Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text15FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text15Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text15Rect), CGRectGetMinY(text15Rect) + (CGRectGetHeight(text15Rect) - text15TextHeight) / 2, CGRectGetWidth(text15Rect), text15TextHeight) withAttributes: text15FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 16 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -73.25, 41.13);
        CGContextRotateCTM(context, 240 * M_PI / 180);

        CGRect text16Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"240°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text16Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text16Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text16FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text16Style};

            CGFloat text16TextHeight = [textContent boundingRectWithSize: CGSizeMake(text16Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text16FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text16Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text16Rect), CGRectGetMinY(text16Rect) + (CGRectGetHeight(text16Rect) - text16TextHeight) / 2, CGRectGetWidth(text16Rect), text16TextHeight) withAttributes: text16FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 17 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -81.4, 20.78);
        CGContextRotateCTM(context, 255 * M_PI / 180);

        CGRect text17Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"255°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text17Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text17Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text17FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text17Style};

            CGFloat text17TextHeight = [textContent boundingRectWithSize: CGSizeMake(text17Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text17FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text17Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text17Rect), CGRectGetMinY(text17Rect) + (CGRectGetHeight(text17Rect) - text17TextHeight) / 2, CGRectGetWidth(text17Rect), text17TextHeight) withAttributes: text17FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 18 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -84, -1);
        CGContextRotateCTM(context, 270 * M_PI / 180);

        CGRect text18Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"270°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text18Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text18Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text18FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text18Style};

            CGFloat text18TextHeight = [textContent boundingRectWithSize: CGSizeMake(text18Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text18FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text18Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text18Rect), CGRectGetMinY(text18Rect) + (CGRectGetHeight(text18Rect) - text18TextHeight) / 2, CGRectGetWidth(text18Rect), text18TextHeight) withAttributes: text18FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 19 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -80.88, -22.71);
        CGContextRotateCTM(context, 285 * M_PI / 180);

        CGRect text19Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"285°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text19Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text19Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text19FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text19Style};

            CGFloat text19TextHeight = [textContent boundingRectWithSize: CGSizeMake(text19Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text19FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text19Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text19Rect), CGRectGetMinY(text19Rect) + (CGRectGetHeight(text19Rect) - text19TextHeight) / 2, CGRectGetWidth(text19Rect), text19TextHeight) withAttributes: text19FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 20 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -72.25, -42.87);
        CGContextRotateCTM(context, 300 * M_PI / 180);

        CGRect text20Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"300°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text20Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text20Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text20FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text20Style};

            CGFloat text20TextHeight = [textContent boundingRectWithSize: CGSizeMake(text20Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text20FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text20Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text20Rect), CGRectGetMinY(text20Rect) + (CGRectGetHeight(text20Rect) - text20TextHeight) / 2, CGRectGetWidth(text20Rect), text20TextHeight) withAttributes: text20FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 21 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -58.69, -60.1);
        CGContextRotateCTM(context, 315 * M_PI / 180);

        CGRect text21Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"315°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text21Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text21Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text21FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text21Style};

            CGFloat text21TextHeight = [textContent boundingRectWithSize: CGSizeMake(text21Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text21FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text21Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text21Rect), CGRectGetMinY(text21Rect) + (CGRectGetHeight(text21Rect) - text21TextHeight) / 2, CGRectGetWidth(text21Rect), text21TextHeight) withAttributes: text21FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 22 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -41.13, -73.25);
        CGContextRotateCTM(context, 330 * M_PI / 180);

        CGRect text22Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"330°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text22Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text22Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text22FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text22Style};

            CGFloat text22TextHeight = [textContent boundingRectWithSize: CGSizeMake(text22Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text22FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text22Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text22Rect), CGRectGetMinY(text22Rect) + (CGRectGetHeight(text22Rect) - text22TextHeight) / 2, CGRectGetWidth(text22Rect), text22TextHeight) withAttributes: text22FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);


        //// Text 23 Drawing
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, -20.78, -81.4);
        CGContextRotateCTM(context, 345 * M_PI / 180);

        CGRect text23Rect = CGRectMake(-6, -4, 12, 8);
        {
            NSString* textContent = @"345°";
            CGContextSaveGState(context);
            CGContextSetShadowWithColor(context, textOuterShowow.shadowOffset, textOuterShowow.shadowBlurRadius, [textOuterShowow.shadowColor CGColor]);
            NSMutableParagraphStyle* text23Style = NSMutableParagraphStyle.defaultParagraphStyle.mutableCopy;
            text23Style.alignment = NSTextAlignmentCenter;

            NSDictionary* text23FontAttributes = @{NSFontAttributeName: [UIFont systemFontOfSize: 5], NSForegroundColorAttributeName: compassTextColor, NSParagraphStyleAttributeName: text23Style};

            CGFloat text23TextHeight = [textContent boundingRectWithSize: CGSizeMake(text23Rect.size.width, INFINITY)  options: NSStringDrawingUsesLineFragmentOrigin attributes: text23FontAttributes context: nil].size.height;
            CGContextSaveGState(context);
            CGContextClipToRect(context, text23Rect);
            [textContent drawInRect: CGRectMake(CGRectGetMinX(text23Rect), CGRectGetMinY(text23Rect) + (CGRectGetHeight(text23Rect) - text23TextHeight) / 2, CGRectGetWidth(text23Rect), text23TextHeight) withAttributes: text23FontAttributes];
            CGContextRestoreGState(context);
            CGContextRestoreGState(context);

        }

        CGContextRestoreGState(context);



        CGContextRestoreGState(context);
    }


    //// outSide 2 Drawing
    UIBezierPath* outSide2Path = UIBezierPath.bezierPath;
    [outSide2Path moveToPoint: CGPointMake(220.5, 120)];
    [outSide2Path addCurveToPoint: CGPointMake(120, 19.5) controlPoint1: CGPointMake(220.5, 64.5) controlPoint2: CGPointMake(175.5, 19.5)];
    [outSide2Path addCurveToPoint: CGPointMake(19.5, 120) controlPoint1: CGPointMake(64.5, 19.5) controlPoint2: CGPointMake(19.5, 64.5)];
    [outSide2Path addCurveToPoint: CGPointMake(120, 220.5) controlPoint1: CGPointMake(19.5, 175.5) controlPoint2: CGPointMake(64.5, 220.5)];
    [outSide2Path addCurveToPoint: CGPointMake(220.5, 120) controlPoint1: CGPointMake(175.5, 220.5) controlPoint2: CGPointMake(220.5, 175.5)];
    [outSide2Path closePath];
    [UIColor.blackColor setStroke];
    outSide2Path.lineWidth = 1;
    [outSide2Path stroke];


    //// Bezier Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 120, 10);
    CGContextRotateCTM(context, -180 * M_PI / 180);

    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(-2, -1.79)];
    [bezierPath addLineToPoint: CGPointMake(-2, 7.5)];
    [bezierPath addLineToPoint: CGPointMake(2, 7.5)];
    [bezierPath addLineToPoint: CGPointMake(2, -1.79)];
    [bezierPath addLineToPoint: CGPointMake(6, -1.5)];
    [bezierPath addLineToPoint: CGPointMake(0, -7.5)];
    [bezierPath addLineToPoint: CGPointMake(-6, -1.5)];
    [bezierPath addLineToPoint: CGPointMake(-2, -1.79)];
    [bezierPath closePath];
    [UIColor.grayColor setFill];
    [bezierPath fill];
    [UIColor.blackColor setStroke];
    bezierPath.lineWidth = 1;
    [bezierPath stroke];

    CGContextRestoreGState(context);
}

+ (void)drawDistanceMeter
{
}

@end



@implementation NSShadow (PaintCodeAdditions)

- (instancetype)initWithColor: (UIColor*)color offset: (CGSize)offset blurRadius: (CGFloat)blurRadius
{
    self = super.init;
    if (self)
    {
        self.shadowColor = color;
        self.shadowOffset = offset;
        self.shadowBlurRadius = blurRadius;
    }
    return self;
}

+ (instancetype)shadowWithColor: (UIColor*)color offset: (CGSize)offset blurRadius: (CGFloat)blurRadius
{
    return [self.alloc initWithColor: color offset: offset blurRadius: blurRadius];
}

- (void)set
{
    CGContextSetShadowWithColor(UIGraphicsGetCurrentContext(), self.shadowOffset, self.shadowBlurRadius, [self.shadowColor CGColor]);
}

@end
